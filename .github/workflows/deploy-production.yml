name: Deploy to Production

on:
  push:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (emergency deployment only)'
        required: false
        type: boolean
        default: false
      skip_backup:
        description: 'Skip database backup (use with caution)'
        required: false
        type: boolean
        default: false

env:
  NODE_ENV: production
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

jobs:
  # Pre-deployment checks and tests
  pre-deployment:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      deployment-id: ${{ steps.generate-id.outputs.deployment-id }}
      should-skip-tests: ${{ inputs.skip_tests || 'false' }}
      should-skip-backup: ${{ inputs.skip_backup || 'false' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate deployment ID
        id: generate-id
        run: echo "deployment-id=deploy-$(date +%s)-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Type check
        run: pnpm typecheck

      - name: Lint check
        run: pnpm lint

      - name: Security audit
        run: pnpm audit --audit-level high
        continue-on-error: true

  # Run tests unless explicitly skipped
  test:
    name: Run Tests
    needs: pre-deployment
    runs-on: ubuntu-latest
    if: needs.pre-deployment.outputs.should-skip-tests == 'false'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Run tests with Neon test database
        uses: ./.github/workflows/neon_workflow.yml@main
        with:
          database_url: ${{ secrets.TEST_DATABASE_URL }}
          database_url_unpooled: ${{ secrets.TEST_DATABASE_URL_UNPOOLED }}

  # Database backup before deployment
  backup:
    name: Backup Database
    needs: [pre-deployment, test]
    runs-on: ubuntu-latest
    if: needs.pre-deployment.outputs.should-skip-backup == 'false' && (success() || needs.test.result == 'skipped')
    outputs:
      backup-path: ${{ steps.backup.outputs.backup_path }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Create database backup
        id: backup
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DATABASE_URL_UNPOOLED: ${{ secrets.DATABASE_URL_UNPOOLED }}
          BACKUP_DIR: ./backups
          BACKUP_COMPRESSION: true
          BACKUP_RETENTION_DAYS: 30
        run: |
          pnpm db:backup
          echo "Backup completed"

      - name: Upload backup artifact
        uses: actions/upload-artifact@v4
        with:
          name: database-backup-${{ needs.pre-deployment.outputs.deployment-id }}
          path: ./backups/
          retention-days: 30

  # Run database migrations
  migrate:
    name: Database Migration
    needs: [pre-deployment, test, backup]
    runs-on: ubuntu-latest
    if: success() || (needs.test.result == 'skipped' && needs.backup.result != 'failure')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Run database migrations
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DATABASE_URL_UNPOOLED: ${{ secrets.DATABASE_URL_UNPOOLED }}
        run: |
          echo "Running production migrations..."
          pnpm db:migrate:prod
          echo "Migrations completed"

      - name: Verify migration status
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          # Basic verification that database is accessible
          node -e "
            const { Client } = require('pg');
            const client = new Client({ connectionString: process.env.DATABASE_URL });
            client.connect().then(() => {
              console.log('âœ… Database connection verified');
              return client.query('SELECT NOW() as current_time');
            }).then(result => {
              console.log('âœ… Database query successful:', result.rows[0]);
              client.end();
            }).catch(err => {
              console.error('âŒ Database verification failed:', err);
              process.exit(1);
            });
          "

  # Deploy to Vercel
  deploy:
    name: Deploy to Vercel
    needs: [pre-deployment, test, backup, migrate]
    runs-on: ubuntu-latest
    if: success() || (needs.test.result == 'skipped' && needs.backup.result != 'failure' && needs.migrate.result != 'failure')
    outputs:
      deployment-url: ${{ steps.deploy.outputs.deployment-url }}
      preview-url: ${{ steps.deploy.outputs.preview-url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Build application
        env:
          # Build-time environment variables
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXT_PUBLIC_STACK_PROJECT_ID: ${{ secrets.NEXT_PUBLIC_STACK_PROJECT_ID }}
          NEXT_PUBLIC_STACK_PUBLISHABLE_CLIENT_KEY: ${{ secrets.NEXT_PUBLIC_STACK_PUBLISHABLE_CLIENT_KEY }}
          STACK_SECRET_SERVER_KEY: ${{ secrets.STACK_SECRET_SERVER_KEY }}
        run: |
          echo "Building application..."
          pnpm build
          echo "Build completed"

      - name: Deploy to Vercel
        id: deploy
        uses: vercel/action@v5
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod --prebuilt'

  # Post-deployment health checks and verification
  verify:
    name: Post-deployment Verification
    needs: [pre-deployment, deploy]
    runs-on: ubuntu-latest
    if: needs.deploy.result == 'success'
    
    steps:
      - name: Wait for deployment to be ready
        run: sleep 30

      - name: Health check - Basic
        id: health-basic
        run: |
          for i in {1..5}; do
            echo "Health check attempt $i/5..."
            
            response=$(curl -s -w "%{http_code}" -o /tmp/health.json "${{ needs.deploy.outputs.deployment-url }}/api/health?type=simple" || echo "000")
            
            if [ "$response" == "200" ]; then
              echo "âœ… Basic health check passed"
              cat /tmp/health.json
              break
            else
              echo "âŒ Health check failed with status: $response"
              if [ -f /tmp/health.json ]; then
                cat /tmp/health.json
              fi
              if [ $i -eq 5 ]; then
                exit 1
              fi
              sleep 10
            fi
          done

      - name: Health check - Detailed
        run: |
          echo "Running detailed health check..."
          response=$(curl -s -w "%{http_code}" -o /tmp/health-detailed.json "${{ needs.deploy.outputs.deployment-url }}/api/health?type=detailed&cache=false")
          
          if [ "$response" == "200" ] || [ "$response" == "206" ]; then
            echo "âœ… Detailed health check passed (status: $response)"
            cat /tmp/health-detailed.json | jq -r '._metadata'
          else
            echo "âš ï¸ Detailed health check failed with status: $response"
            cat /tmp/health-detailed.json
            # Don't fail deployment for detailed health check issues
          fi

      - name: Feature flags check
        run: |
          echo "Checking feature flags..."
          response=$(curl -s -w "%{http_code}" -o /tmp/features.json "${{ needs.deploy.outputs.deployment-url }}/api/feature-flags")
          
          if [ "$response" == "200" ]; then
            echo "âœ… Feature flags endpoint working"
            cat /tmp/features.json | jq -r '.flags'
          else
            echo "âŒ Feature flags check failed with status: $response"
            exit 1
          fi

      - name: Performance check
        run: |
          echo "Basic performance check..."
          start_time=$(date +%s%N)
          curl -s "${{ needs.deploy.outputs.deployment-url }}" > /dev/null
          end_time=$(date +%s%N)
          
          duration=$(( (end_time - start_time) / 1000000 )) # Convert to milliseconds
          echo "Page load time: ${duration}ms"
          
          if [ $duration -gt 5000 ]; then
            echo "âš ï¸ Warning: Page load time is high (${duration}ms > 5000ms)"
          else
            echo "âœ… Page load time acceptable: ${duration}ms"
          fi

  # Notification and cleanup
  notify:
    name: Deployment Notification
    needs: [pre-deployment, deploy, verify]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Deployment Success Notification
        if: needs.deploy.result == 'success' && needs.verify.result == 'success'
        run: |
          echo "ðŸŽ‰ Deployment successful!"
          echo "Deployment URL: ${{ needs.deploy.outputs.deployment-url }}"
          echo "Deployment ID: ${{ needs.pre-deployment.outputs.deployment-id }}"
          echo "Commit: ${{ github.sha }}"
          
          # Add status to GitHub
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "${{ github.api_url }}/repos/${{ github.repository }}/statuses/${{ github.sha }}" \
            -d '{
              "state": "success",
              "description": "Production deployment successful",
              "context": "deploy/production"
            }'

      - name: Deployment Failure Notification
        if: needs.deploy.result == 'failure' || needs.verify.result == 'failure'
        run: |
          echo "âŒ Deployment failed!"
          echo "Please check the logs and consider rollback if needed"
          
          # Add status to GitHub
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "${{ github.api_url }}/repos/${{ github.repository }}/statuses/${{ github.sha }}" \
            -d '{
              "state": "failure",
              "description": "Production deployment failed",
              "context": "deploy/production"
            }'

      - name: Create deployment record
        if: needs.deploy.result == 'success'
        run: |
          # Create a simple deployment record
          mkdir -p .deployments
          cat > .deployments/${{ needs.pre-deployment.outputs.deployment-id }}.json << EOF
          {
            "id": "${{ needs.pre-deployment.outputs.deployment-id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "actor": "${{ github.actor }}",
            "url": "${{ needs.deploy.outputs.deployment-url }}",
            "status": "${{ needs.verify.result }}",
            "tests_skipped": ${{ needs.pre-deployment.outputs.should-skip-tests }},
            "backup_skipped": ${{ needs.pre-deployment.outputs.should-skip-backup }}
          }
          EOF
          
          echo "Deployment record created"